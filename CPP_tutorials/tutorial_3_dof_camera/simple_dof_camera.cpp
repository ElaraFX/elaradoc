/////////////////////////////////////////////////////
// Module initialization and cleanup.
//
// Copyright 2013-2016 Rendease Co., Ltd. All Rights Reserved.
//

#include <ei_shaderx.h>

inline void concentric_sample_disk(
	eiScalar & dx, eiScalar & dy, 
	eiScalar u1, eiScalar u2)
{
	eiScalar r, theta;
	eiScalar sx = 2.0f * u1 - 1.0f;
	eiScalar sy = 2.0f * u2 - 1.0f;
	if (sx == 0.0f && sy == 0.0f) {
		dx = 0.0f;
		dy = 0.0f;
		return;
	}
	if (sx >= -sy) {
		if (sx > sy) {
			r = sx;
			if (sy > 0.0f)
				theta = sy/r;
			else
				theta = 8.0f + sy/r;
		}
		else {
			r = sy;
			theta = 2.0f - sx/r;
		}
	}
	else {
		if (sx <= sy) {
			r = -sx;
			theta = 4.0f - sy/r;
		}
		else {
			r = -sy;
			theta = 6.0f + sx/r;
		}
	}
	theta *= (eiScalar)EI_PI / 4.0f;
	dx = r * cosf(theta);
	dy = r * sinf(theta);
}

/** Simple DOF camera
 */
lens (simple_dof_camera)

	enum
	{
		e_fstop = 0, 
		e_fplane, 
	};

	static void parameters()
	{
		declare_scalar(fstop, 1.0f);
		declare_scalar(fplane, 1.0f);
	}

	static void init()
	{
	}

	static void exit()
	{
	}

	void init_node()
	{
	}

	void exit_node()
	{
	}

	eiBool support(
		eiNode *cam, 
		eiInt feature)
	{
		return ei_std_camera_support(cam, feature);
	}

	eiBool object_to_screen(
		eiNode *cam, 
		eiVector *rpos, 
		const eiVector *opos, 
		const eiMatrix *object_to_view)
	{
		return ei_std_camera_object_to_screen(cam, rpos, opos, object_to_view);
	}

	void update_world_bbox(
		eiNode *cam, 
		const eiBBox *world_bbox)
	{
		ei_std_camera_update_world_bbox(cam, world_bbox);
	}

	eiBool generate_ray(
		eiNode *cam, 
		eiCameraOutput *out)
	{
		eiBool ret_val = ei_std_camera_generate_ray(this, cam, out);

		/* modify ray generated by standard camera to simulate DOF */
		eiScalar focal = ei_node_get_scalar(cam, EI_CAMERA_focal);
		if (focal != EI_MAX_SCALAR) /* only work for perspective camera */
		{
			eiScalar fstop = eval_scalar(fstop);
			eiScalar fplane = eval_scalar(fplane);

			eiVector2 rand;
			eiScalar dof_dx, dof_dy;
			ei_lens_sample(&rand, this);

			concentric_sample_disk(
				dof_dx, dof_dy, 
				rand.x, rand.y);
			}

			out->E = ei_point(
				dof_dx * fstop * 0.5f, 
				dof_dy * fstop * 0.5f, 
				0.0f);

			out->I = normalize(out->I * (fplane / absf(out->I[2])) - out->E);
		}

		ei_ray_from_camera(out, cam, time);
		return ret_val;
	}

end_lens (simple_dof_camera)
